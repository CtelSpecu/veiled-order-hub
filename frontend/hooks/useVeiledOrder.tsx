"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at 
  <root>/scripts/genabi.mjs. This script parses the 
  <root>/packages/fhevm-hardhat-template/deployments directory to retrieve 
  deployment information for VeiledOrder.sol:
  
  - <root>/packages/site/abi/abi/VeiledOrderABI.ts
  - <root>/packages/site/abi/abi/VeiledOrderAddresses.ts
*/
import { VeiledOrderAddresses } from "@/abi/VeiledOrderAddresses";
import { VeiledOrderABI } from "@/abi/VeiledOrderABI";

export type OrderInfo = {
  orderIndex: number;
  amountHandle: string;
  priceHandle: string;
  isBuy: boolean;
  timestamp: bigint;
  owner: string;
};

export type ClearOrder = {
  orderIndex: number;
  amount: bigint;
  price: bigint;
  isBuy: boolean;
  timestamp: bigint;
  owner: string;
};

type VeiledOrderInfoType = {
  abi: typeof VeiledOrderABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves VeiledOrder contract metadata for the given EVM `chainId`.
 */
function getVeiledOrderByChainId(
  chainId: number | undefined
): VeiledOrderInfoType {
  if (!chainId) {
    return { abi: VeiledOrderABI.abi };
  }

  const entry =
    VeiledOrderAddresses[chainId.toString() as keyof typeof VeiledOrderAddresses];

  if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: VeiledOrderABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: VeiledOrderABI.abi,
  };
}

export const useVeiledOrder = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs
  //////////////////////////////////////////////////////////////////////////////

  const [myOrderIndices, setMyOrderIndices] = useState<number[]>([]);
  const [orders, setOrders] = useState<Map<number, OrderInfo>>(new Map());
  const [clearOrders, setClearOrders] = useState<Map<number, ClearOrder>>(new Map());
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const veiledOrderRef = useRef<VeiledOrderInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isSubmittingRef = useRef<boolean>(isSubmitting);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const ordersRef = useRef<Map<number, OrderInfo>>(new Map());
  const clearOrdersRef = useRef<Map<number, ClearOrder>>(new Map());

  //////////////////////////////////////////////////////////////////////////////
  // VeiledOrder Contract
  //////////////////////////////////////////////////////////////////////////////

  const veiledOrder = useMemo(() => {
    const c = getVeiledOrderByChainId(chainId);

    veiledOrderRef.current = c;

    if (!c.address) {
      setMessage(`VeiledOrder deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Contract Deployment Status
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!veiledOrder) {
      return undefined;
    }
    return (
      Boolean(veiledOrder.address) &&
      veiledOrder.address !== ethers.ZeroAddress
    );
  }, [veiledOrder]);

  //////////////////////////////////////////////////////////////////////////////
  // Refresh My Orders
  //////////////////////////////////////////////////////////////////////////////

  const canRefresh = useMemo(() => {
    return (
      veiledOrder.address &&
      ethersReadonlyProvider &&
      ethersSigner &&
      !isRefreshing
    );
  }, [veiledOrder.address, ethersReadonlyProvider, ethersSigner, isRefreshing]);

  const refreshMyOrders = useCallback(() => {
    console.log("[useVeiledOrder] call refreshMyOrders()");
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !veiledOrderRef.current ||
      !veiledOrderRef.current?.chainId ||
      !veiledOrderRef.current?.address ||
      !ethersReadonlyProvider ||
      !ethersSigner
    ) {
      setMyOrderIndices([]);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = veiledOrderRef.current.chainId;
    const thisAddress = veiledOrderRef.current.address;
    const thisSigner = ethersSigner;

    const thisContract = new ethers.Contract(
      thisAddress,
      veiledOrderRef.current.abi,
      thisSigner
    );

    thisContract
      .getMyOrderIndices()
      .then(async (indices: bigint[]) => {
        console.log("[useVeiledOrder] getMyOrderIndices()=" + indices);
        if (
          sameChain.current(thisChainId) &&
          thisAddress === veiledOrderRef.current?.address &&
          sameSigner.current(thisSigner)
        ) {
          const orderIndices = indices.map((i) => Number(i));
          setMyOrderIndices(orderIndices);

          // Fetch order details for each index
          const newOrders = new Map<number, OrderInfo>();
          for (const idx of orderIndices) {
            try {
              const orderData = await thisContract.getOrder(idx);
              newOrders.set(idx, {
                orderIndex: idx,
                amountHandle: orderData.amount,
                priceHandle: orderData.price,
                isBuy: orderData.isBuy,
                timestamp: orderData.timestamp,
                owner: orderData.owner,
              });
            } catch (e) {
              console.error(`Failed to fetch order ${idx}:`, e);
            }
          }
          setOrders(newOrders);
          ordersRef.current = newOrders;
        }

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("VeiledOrder.getMyOrderIndices() call failed! error=" + e);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, ethersSigner, sameChain, sameSigner]);

  // Auto refresh orders when signer or chain changes
  useEffect(() => {
    if (ethersSigner && veiledOrder.address) {
      refreshMyOrders();
    }
  }, [ethersSigner, veiledOrder.address, refreshMyOrders]);

  //////////////////////////////////////////////////////////////////////////////
  // Submit Order
  //////////////////////////////////////////////////////////////////////////////

  const canSubmit = useMemo(() => {
    return (
      veiledOrder.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isSubmitting
    );
  }, [
    veiledOrder.address,
    instance,
    ethersSigner,
    isRefreshing,
    isSubmitting,
  ]);

  const submitOrder = useCallback(
    (amount: number, price: number, isBuy: boolean) => {
      if (isRefreshingRef.current || isSubmittingRef.current) {
        return;
      }

      if (!veiledOrder.address || !instance || !ethersSigner) {
        return;
      }

      // Scale by 1000 to support decimals
      const scaledAmount = Math.floor(amount * 1000);
      const scaledPrice = Math.floor(price * 1000);

      if (scaledAmount <= 0 || scaledPrice <= 0) {
        setMessage("Amount and price must be greater than 0");
        return;
      }

      const thisChainId = chainId;
      const thisAddress = veiledOrder.address;
      const thisSigner = ethersSigner;
      const thisContract = new ethers.Contract(
        thisAddress,
        veiledOrder.abi,
        thisSigner
      );

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage(`Submitting ${isBuy ? "buy" : "sell"} order...`);

      const run = async () => {
        // Let the browser repaint before running 'input.encrypt()' (CPU-costly)
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisAddress !== veiledOrderRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisSigner);

        try {
          const input = instance.createEncryptedInput(
            thisAddress,
            thisSigner.address
          );
          input.add32(scaledAmount);
          input.add32(scaledPrice);

          // CPU-intensive (browser may freeze a little when FHE-WASM modules are loading)
          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Ignore order submission");
            return;
          }

          setMessage("Call submitOrder...");

          // Call contract
          const tx: ethers.TransactionResponse = await thisContract.submitOrder(
            enc.handles[0], // amount
            enc.handles[1], // price
            isBuy,
            enc.inputProof
          );

          setMessage(`Wait for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(
            `Order submitted! status=${receipt?.status}, tx=${tx.hash}`
          );

          if (isStale()) {
            setMessage("Ignore order submission");
            return;
          }

          // Refresh orders after submission
          refreshMyOrders();
        } catch (e: any) {
          const base = `Order submission failed! error=${e?.message || String(e)}`;
          const extra =
            typeof e?.message === "string" &&
            (e.message.includes("400") ||
              e.message.includes("Bad Request") ||
              e.message.includes("input-proof"))
              ? " The relayer rejected the input-proof. Ensure you're on Sepolia with a whitelisted contract/ACL and that the relayer is reachable."
              : typeof e?.message === "string" &&
                e.message.includes("UNSUPPORTED_RELAYER_CHAIN")
              ? " Switch to Sepolia (11155111) or run against an FHEVM Hardhat node."
              : "";
          setMessage(base + extra);
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      veiledOrder.address,
      veiledOrder.abi,
      instance,
      chainId,
      refreshMyOrders,
      sameChain,
      sameSigner,
    ]
  );

  //////////////////////////////////////////////////////////////////////////////
  // Decrypt Order
  //////////////////////////////////////////////////////////////////////////////

  const canDecrypt = useMemo(() => {
    return (
      veiledOrder.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      orders.size > 0
    );
  }, [
    veiledOrder.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    orders.size,
  ]);

  const decryptOrder = useCallback(
    (orderIndex: number) => {
      if (isRefreshingRef.current || isDecryptingRef.current) {
        return;
      }

      if (!veiledOrder.address || !instance || !ethersSigner) {
        return;
      }

      const order = ordersRef.current.get(orderIndex);
      if (!order) {
        setMessage(`Order ${orderIndex} not found`);
        return;
      }

      // Already decrypted
      if (clearOrdersRef.current.has(orderIndex)) {
        return;
      }

      const thisChainId = chainId;
      const thisAddress = veiledOrder.address;
      const thisOrderIndex = orderIndex;
      const thisAmountHandle = order.amountHandle;
      const thisPriceHandle = order.priceHandle;
      const thisSigner = ethersSigner;

      isDecryptingRef.current = true;
      setIsDecrypting(true);
      setMessage(`Decrypting order ${orderIndex}...`);

      const run = async () => {
        const isStale = () =>
          thisAddress !== veiledOrderRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisSigner);

        try {
          const sig: FhevmDecryptionSignature | null =
            await FhevmDecryptionSignature.loadOrSign(
              instance,
              [veiledOrder.address as `0x${string}`],
              ethersSigner,
              fhevmDecryptionSignatureStorage
            );

          if (!sig) {
            setMessage("Unable to build FHEVM decryption signature");
            return;
          }

          if (isStale()) {
            setMessage("Ignore FHEVM decryption");
            return;
          }

          setMessage("Call FHEVM userDecrypt...");

          const res = await instance.userDecrypt(
            [
              { handle: thisAmountHandle, contractAddress: thisAddress },
              { handle: thisPriceHandle, contractAddress: thisAddress },
            ],
            sig.privateKey,
            sig.publicKey,
            sig.signature,
            sig.contractAddresses,
            sig.userAddress,
            sig.startTimestamp,
            sig.durationDays
          );

          setMessage("FHEVM userDecrypt completed!");

          if (isStale()) {
            setMessage("Ignore FHEVM decryption");
            return;
          }

          const clearOrder: ClearOrder = {
            orderIndex: thisOrderIndex,
            amount: (res[thisAmountHandle] as bigint) / BigInt(1000), // Unscale
            price: (res[thisPriceHandle] as bigint) / BigInt(1000), // Unscale
            isBuy: order.isBuy,
            timestamp: order.timestamp,
            owner: order.owner,
          };

          const newClearOrders = new Map(clearOrdersRef.current);
          newClearOrders.set(thisOrderIndex, clearOrder);
          setClearOrders(newClearOrders);
          clearOrdersRef.current = newClearOrders;

          setMessage(
            `Order ${orderIndex} decrypted: amount=${clearOrder.amount}, price=${clearOrder.price}`
          );
        } catch (e: any) {
          const base = `Decryption failed! error=${e?.message || String(e)}`;
          const extra =
            typeof e?.message === "string" &&
            (e.message.includes("400") ||
              e.message.includes("Bad Request") ||
              e.message.includes("input-proof"))
              ? " The relayer could not process the request. Ensure Sepolia network and ACL/contract are registered with the relayer."
              : typeof e?.message === "string" &&
                e.message.includes("UNSUPPORTED_RELAYER_CHAIN")
              ? " Switch to Sepolia (11155111) or use an FHEVM Hardhat node."
              : "";
          setMessage(base + extra);
        } finally {
          isDecryptingRef.current = false;
          setIsDecrypting(false);
        }
      };

      run();
    },
    [
      fhevmDecryptionSignatureStorage,
      ethersSigner,
      veiledOrder.address,
      instance,
      orders,
      chainId,
      sameChain,
      sameSigner,
    ]
  );

  return {
    contractAddress: veiledOrder.address,
    isDeployed,
    canRefresh,
    canSubmit,
    canDecrypt,
    refreshMyOrders,
    submitOrder,
    decryptOrder,
    myOrderIndices,
    orders: Array.from(orders.values()),
    clearOrders: Array.from(clearOrders.values()),
    getClearOrder: (orderIndex: number) => clearOrders.get(orderIndex),
    message,
    isRefreshing,
    isSubmitting,
    isDecrypting,
  };
};

